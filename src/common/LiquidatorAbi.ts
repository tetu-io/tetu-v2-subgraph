// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class BlueChipAdded extends ethereum.Event {
  get params(): BlueChipAdded__Params {
    return new BlueChipAdded__Params(this);
  }
}

export class BlueChipAdded__Params {
  _event: BlueChipAdded;

  constructor(event: BlueChipAdded) {
    this._event = event;
  }

  get poolData(): BlueChipAddedPoolDataStruct {
    return changetype<BlueChipAddedPoolDataStruct>(
      this._event.parameters[0].value.toTuple()
    );
  }
}

export class BlueChipAddedPoolDataStruct extends ethereum.Tuple {
  get pool(): Address {
    return this[0].toAddress();
  }

  get swapper(): Address {
    return this[1].toAddress();
  }

  get tokenIn(): Address {
    return this[2].toAddress();
  }

  get tokenOut(): Address {
    return this[3].toAddress();
  }
}

export class ContractInitialized extends ethereum.Event {
  get params(): ContractInitialized__Params {
    return new ContractInitialized__Params(this);
  }
}

export class ContractInitialized__Params {
  _event: ContractInitialized;

  constructor(event: ContractInitialized) {
    this._event = event;
  }

  get controller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get ts(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get block(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Initialized extends ethereum.Event {
  get params(): Initialized__Params {
    return new Initialized__Params(this);
  }
}

export class Initialized__Params {
  _event: Initialized;

  constructor(event: Initialized) {
    this._event = event;
  }

  get version(): i32 {
    return this._event.parameters[0].value.toI32();
  }
}

export class Liquidated extends ethereum.Event {
  get params(): Liquidated__Params {
    return new Liquidated__Params(this);
  }
}

export class Liquidated__Params {
  _event: Liquidated;

  constructor(event: Liquidated) {
    this._event = event;
  }

  get tokenIn(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get tokenOut(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class PoolAdded extends ethereum.Event {
  get params(): PoolAdded__Params {
    return new PoolAdded__Params(this);
  }
}

export class PoolAdded__Params {
  _event: PoolAdded;

  constructor(event: PoolAdded) {
    this._event = event;
  }

  get poolData(): PoolAddedPoolDataStruct {
    return changetype<PoolAddedPoolDataStruct>(
      this._event.parameters[0].value.toTuple()
    );
  }
}

export class PoolAddedPoolDataStruct extends ethereum.Tuple {
  get pool(): Address {
    return this[0].toAddress();
  }

  get swapper(): Address {
    return this[1].toAddress();
  }

  get tokenIn(): Address {
    return this[2].toAddress();
  }

  get tokenOut(): Address {
    return this[3].toAddress();
  }
}

export class RevisionIncreased extends ethereum.Event {
  get params(): RevisionIncreased__Params {
    return new RevisionIncreased__Params(this);
  }
}

export class RevisionIncreased__Params {
  _event: RevisionIncreased;

  constructor(event: RevisionIncreased) {
    this._event = event;
  }

  get value(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get oldLogic(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LiquidatorAbi__blueChipsPoolsResult {
  value0: Address;
  value1: Address;
  value2: Address;
  value3: Address;

  constructor(
    value0: Address,
    value1: Address,
    value2: Address,
    value3: Address
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromAddress(this.value3));
    return map;
  }

  getPool(): Address {
    return this.value0;
  }

  getSwapper(): Address {
    return this.value1;
  }

  getTokenIn(): Address {
    return this.value2;
  }

  getTokenOut(): Address {
    return this.value3;
  }
}

export class LiquidatorAbi__buildRouteResultRouteStruct extends ethereum.Tuple {
  get pool(): Address {
    return this[0].toAddress();
  }

  get swapper(): Address {
    return this[1].toAddress();
  }

  get tokenIn(): Address {
    return this[2].toAddress();
  }

  get tokenOut(): Address {
    return this[3].toAddress();
  }
}

export class LiquidatorAbi__buildRouteResult {
  value0: Array<LiquidatorAbi__buildRouteResultRouteStruct>;
  value1: string;

  constructor(
    value0: Array<LiquidatorAbi__buildRouteResultRouteStruct>,
    value1: string
  ) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromTupleArray(this.value0));
    map.set("value1", ethereum.Value.fromString(this.value1));
    return map;
  }

  getRoute(): Array<LiquidatorAbi__buildRouteResultRouteStruct> {
    return this.value0;
  }

  getErrorMessage(): string {
    return this.value1;
  }
}

export class LiquidatorAbi__getPriceForRouteInputRouteStruct extends ethereum.Tuple {
  get pool(): Address {
    return this[0].toAddress();
  }

  get swapper(): Address {
    return this[1].toAddress();
  }

  get tokenIn(): Address {
    return this[2].toAddress();
  }

  get tokenOut(): Address {
    return this[3].toAddress();
  }
}

export class LiquidatorAbi__largestPoolsResult {
  value0: Address;
  value1: Address;
  value2: Address;
  value3: Address;

  constructor(
    value0: Address,
    value1: Address,
    value2: Address,
    value3: Address
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromAddress(this.value3));
    return map;
  }

  getPool(): Address {
    return this.value0;
  }

  getSwapper(): Address {
    return this.value1;
  }

  getTokenIn(): Address {
    return this.value2;
  }

  getTokenOut(): Address {
    return this.value3;
  }
}

export class LiquidatorAbi extends ethereum.SmartContract {
  static bind(address: Address): LiquidatorAbi {
    return new LiquidatorAbi("LiquidatorAbi", address);
  }

  CONTROLLABLE_VERSION(): string {
    let result = super.call(
      "CONTROLLABLE_VERSION",
      "CONTROLLABLE_VERSION():(string)",
      []
    );

    return result[0].toString();
  }

  try_CONTROLLABLE_VERSION(): ethereum.CallResult<string> {
    let result = super.tryCall(
      "CONTROLLABLE_VERSION",
      "CONTROLLABLE_VERSION():(string)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  LIQUIDATOR_VERSION(): string {
    let result = super.call(
      "LIQUIDATOR_VERSION",
      "LIQUIDATOR_VERSION():(string)",
      []
    );

    return result[0].toString();
  }

  try_LIQUIDATOR_VERSION(): ethereum.CallResult<string> {
    let result = super.tryCall(
      "LIQUIDATOR_VERSION",
      "LIQUIDATOR_VERSION():(string)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  ROUTE_LENGTH_MAX(): BigInt {
    let result = super.call(
      "ROUTE_LENGTH_MAX",
      "ROUTE_LENGTH_MAX():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_ROUTE_LENGTH_MAX(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "ROUTE_LENGTH_MAX",
      "ROUTE_LENGTH_MAX():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  blueChipsPools(
    param0: Address,
    param1: Address
  ): LiquidatorAbi__blueChipsPoolsResult {
    let result = super.call(
      "blueChipsPools",
      "blueChipsPools(address,address):(address,address,address,address)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return new LiquidatorAbi__blueChipsPoolsResult(
      result[0].toAddress(),
      result[1].toAddress(),
      result[2].toAddress(),
      result[3].toAddress()
    );
  }

  try_blueChipsPools(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<LiquidatorAbi__blueChipsPoolsResult> {
    let result = super.tryCall(
      "blueChipsPools",
      "blueChipsPools(address,address):(address,address,address,address)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LiquidatorAbi__blueChipsPoolsResult(
        value[0].toAddress(),
        value[1].toAddress(),
        value[2].toAddress(),
        value[3].toAddress()
      )
    );
  }

  blueChipsTokens(param0: Address): boolean {
    let result = super.call(
      "blueChipsTokens",
      "blueChipsTokens(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_blueChipsTokens(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "blueChipsTokens",
      "blueChipsTokens(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  buildRoute(
    tokenIn: Address,
    tokenOut: Address
  ): LiquidatorAbi__buildRouteResult {
    let result = super.call(
      "buildRoute",
      "buildRoute(address,address):((address,address,address,address)[],string)",
      [
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut)
      ]
    );

    return new LiquidatorAbi__buildRouteResult(
      result[0].toTupleArray<LiquidatorAbi__buildRouteResultRouteStruct>(),
      result[1].toString()
    );
  }

  try_buildRoute(
    tokenIn: Address,
    tokenOut: Address
  ): ethereum.CallResult<LiquidatorAbi__buildRouteResult> {
    let result = super.tryCall(
      "buildRoute",
      "buildRoute(address,address):((address,address,address,address)[],string)",
      [
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LiquidatorAbi__buildRouteResult(
        value[0].toTupleArray<LiquidatorAbi__buildRouteResultRouteStruct>(),
        value[1].toString()
      )
    );
  }

  controller(): Address {
    let result = super.call("controller", "controller():(address)", []);

    return result[0].toAddress();
  }

  try_controller(): ethereum.CallResult<Address> {
    let result = super.tryCall("controller", "controller():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  created(): BigInt {
    let result = super.call("created", "created():(uint256)", []);

    return result[0].toBigInt();
  }

  try_created(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("created", "created():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  createdBlock(): BigInt {
    let result = super.call("createdBlock", "createdBlock():(uint256)", []);

    return result[0].toBigInt();
  }

  try_createdBlock(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("createdBlock", "createdBlock():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPrice(tokenIn: Address, tokenOut: Address, amount: BigInt): BigInt {
    let result = super.call(
      "getPrice",
      "getPrice(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPrice(
    tokenIn: Address,
    tokenOut: Address,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPrice",
      "getPrice(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriceForRoute(
    route: Array<LiquidatorAbi__getPriceForRouteInputRouteStruct>,
    amount: BigInt
  ): BigInt {
    let result = super.call(
      "getPriceForRoute",
      "getPriceForRoute((address,address,address,address)[],uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(route),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );

    return result[0].toBigInt();
  }

  try_getPriceForRoute(
    route: Array<LiquidatorAbi__getPriceForRouteInputRouteStruct>,
    amount: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPriceForRoute",
      "getPriceForRoute((address,address,address,address)[],uint256):(uint256)",
      [
        ethereum.Value.fromTupleArray(route),
        ethereum.Value.fromUnsignedBigInt(amount)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isController(_value: Address): boolean {
    let result = super.call("isController", "isController(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);

    return result[0].toBoolean();
  }

  try_isController(_value: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isController", "isController(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isGovernance(_value: Address): boolean {
    let result = super.call("isGovernance", "isGovernance(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);

    return result[0].toBoolean();
  }

  try_isGovernance(_value: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isGovernance", "isGovernance(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isRouteExist(tokenIn: Address, tokenOut: Address): boolean {
    let result = super.call(
      "isRouteExist",
      "isRouteExist(address,address):(bool)",
      [
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut)
      ]
    );

    return result[0].toBoolean();
  }

  try_isRouteExist(
    tokenIn: Address,
    tokenOut: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isRouteExist",
      "isRouteExist(address,address):(bool)",
      [
        ethereum.Value.fromAddress(tokenIn),
        ethereum.Value.fromAddress(tokenOut)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  largestPools(param0: Address): LiquidatorAbi__largestPoolsResult {
    let result = super.call(
      "largestPools",
      "largestPools(address):(address,address,address,address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return new LiquidatorAbi__largestPoolsResult(
      result[0].toAddress(),
      result[1].toAddress(),
      result[2].toAddress(),
      result[3].toAddress()
    );
  }

  try_largestPools(
    param0: Address
  ): ethereum.CallResult<LiquidatorAbi__largestPoolsResult> {
    let result = super.tryCall(
      "largestPools",
      "largestPools(address):(address,address,address,address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LiquidatorAbi__largestPoolsResult(
        value[0].toAddress(),
        value[1].toAddress(),
        value[2].toAddress(),
        value[3].toAddress()
      )
    );
  }

  previousImplementation(): Address {
    let result = super.call(
      "previousImplementation",
      "previousImplementation():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_previousImplementation(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "previousImplementation",
      "previousImplementation():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  revision(): BigInt {
    let result = super.call("revision", "revision():(uint256)", []);

    return result[0].toBigInt();
  }

  try_revision(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("revision", "revision():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class __Controllable_initCall extends ethereum.Call {
  get inputs(): __Controllable_initCall__Inputs {
    return new __Controllable_initCall__Inputs(this);
  }

  get outputs(): __Controllable_initCall__Outputs {
    return new __Controllable_initCall__Outputs(this);
  }
}

export class __Controllable_initCall__Inputs {
  _call: __Controllable_initCall;

  constructor(call: __Controllable_initCall) {
    this._call = call;
  }

  get controller_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class __Controllable_initCall__Outputs {
  _call: __Controllable_initCall;

  constructor(call: __Controllable_initCall) {
    this._call = call;
  }
}

export class AddBlueChipsPoolsCall extends ethereum.Call {
  get inputs(): AddBlueChipsPoolsCall__Inputs {
    return new AddBlueChipsPoolsCall__Inputs(this);
  }

  get outputs(): AddBlueChipsPoolsCall__Outputs {
    return new AddBlueChipsPoolsCall__Outputs(this);
  }
}

export class AddBlueChipsPoolsCall__Inputs {
  _call: AddBlueChipsPoolsCall;

  constructor(call: AddBlueChipsPoolsCall) {
    this._call = call;
  }

  get _pools(): Array<AddBlueChipsPoolsCall_poolsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      AddBlueChipsPoolsCall_poolsStruct
    >();
  }

  get rewrite(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class AddBlueChipsPoolsCall__Outputs {
  _call: AddBlueChipsPoolsCall;

  constructor(call: AddBlueChipsPoolsCall) {
    this._call = call;
  }
}

export class AddBlueChipsPoolsCall_poolsStruct extends ethereum.Tuple {
  get pool(): Address {
    return this[0].toAddress();
  }

  get swapper(): Address {
    return this[1].toAddress();
  }

  get tokenIn(): Address {
    return this[2].toAddress();
  }

  get tokenOut(): Address {
    return this[3].toAddress();
  }
}

export class AddLargestPoolsCall extends ethereum.Call {
  get inputs(): AddLargestPoolsCall__Inputs {
    return new AddLargestPoolsCall__Inputs(this);
  }

  get outputs(): AddLargestPoolsCall__Outputs {
    return new AddLargestPoolsCall__Outputs(this);
  }
}

export class AddLargestPoolsCall__Inputs {
  _call: AddLargestPoolsCall;

  constructor(call: AddLargestPoolsCall) {
    this._call = call;
  }

  get _pools(): Array<AddLargestPoolsCall_poolsStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      AddLargestPoolsCall_poolsStruct
    >();
  }

  get rewrite(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class AddLargestPoolsCall__Outputs {
  _call: AddLargestPoolsCall;

  constructor(call: AddLargestPoolsCall) {
    this._call = call;
  }
}

export class AddLargestPoolsCall_poolsStruct extends ethereum.Tuple {
  get pool(): Address {
    return this[0].toAddress();
  }

  get swapper(): Address {
    return this[1].toAddress();
  }

  get tokenIn(): Address {
    return this[2].toAddress();
  }

  get tokenOut(): Address {
    return this[3].toAddress();
  }
}

export class IncreaseRevisionCall extends ethereum.Call {
  get inputs(): IncreaseRevisionCall__Inputs {
    return new IncreaseRevisionCall__Inputs(this);
  }

  get outputs(): IncreaseRevisionCall__Outputs {
    return new IncreaseRevisionCall__Outputs(this);
  }
}

export class IncreaseRevisionCall__Inputs {
  _call: IncreaseRevisionCall;

  constructor(call: IncreaseRevisionCall) {
    this._call = call;
  }

  get oldLogic(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class IncreaseRevisionCall__Outputs {
  _call: IncreaseRevisionCall;

  constructor(call: IncreaseRevisionCall) {
    this._call = call;
  }
}

export class InitCall extends ethereum.Call {
  get inputs(): InitCall__Inputs {
    return new InitCall__Inputs(this);
  }

  get outputs(): InitCall__Outputs {
    return new InitCall__Outputs(this);
  }
}

export class InitCall__Inputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }

  get controller_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitCall__Outputs {
  _call: InitCall;

  constructor(call: InitCall) {
    this._call = call;
  }
}

export class LiquidateCall extends ethereum.Call {
  get inputs(): LiquidateCall__Inputs {
    return new LiquidateCall__Inputs(this);
  }

  get outputs(): LiquidateCall__Outputs {
    return new LiquidateCall__Outputs(this);
  }
}

export class LiquidateCall__Inputs {
  _call: LiquidateCall;

  constructor(call: LiquidateCall) {
    this._call = call;
  }

  get tokenIn(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenOut(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get slippage(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class LiquidateCall__Outputs {
  _call: LiquidateCall;

  constructor(call: LiquidateCall) {
    this._call = call;
  }
}

export class LiquidateWithRouteCall extends ethereum.Call {
  get inputs(): LiquidateWithRouteCall__Inputs {
    return new LiquidateWithRouteCall__Inputs(this);
  }

  get outputs(): LiquidateWithRouteCall__Outputs {
    return new LiquidateWithRouteCall__Outputs(this);
  }
}

export class LiquidateWithRouteCall__Inputs {
  _call: LiquidateWithRouteCall;

  constructor(call: LiquidateWithRouteCall) {
    this._call = call;
  }

  get route(): Array<LiquidateWithRouteCallRouteStruct> {
    return this._call.inputValues[0].value.toTupleArray<
      LiquidateWithRouteCallRouteStruct
    >();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get slippage(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class LiquidateWithRouteCall__Outputs {
  _call: LiquidateWithRouteCall;

  constructor(call: LiquidateWithRouteCall) {
    this._call = call;
  }
}

export class LiquidateWithRouteCallRouteStruct extends ethereum.Tuple {
  get pool(): Address {
    return this[0].toAddress();
  }

  get swapper(): Address {
    return this[1].toAddress();
  }

  get tokenIn(): Address {
    return this[2].toAddress();
  }

  get tokenOut(): Address {
    return this[3].toAddress();
  }
}
