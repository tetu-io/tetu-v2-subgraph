// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class ContractInitialized extends ethereum.Event {
  get params(): ContractInitialized__Params {
    return new ContractInitialized__Params(this);
  }
}

export class ContractInitialized__Params {
  _event: ContractInitialized;

  constructor(event: ContractInitialized) {
    this._event = event;
  }

  get controller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get ts(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get block(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class DefaultTokenChanged extends ethereum.Event {
  get params(): DefaultTokenChanged__Params {
    return new DefaultTokenChanged__Params(this);
  }
}

export class DefaultTokenChanged__Params {
  _event: DefaultTokenChanged;

  constructor(event: DefaultTokenChanged) {
    this._event = event;
  }

  get oldToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class KeyTokenAdded extends ethereum.Event {
  get params(): KeyTokenAdded__Params {
    return new KeyTokenAdded__Params(this);
  }
}

export class KeyTokenAdded__Params {
  _event: KeyTokenAdded;

  constructor(event: KeyTokenAdded) {
    this._event = event;
  }

  get newKeyToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class KeyTokenRemoved extends ethereum.Event {
  get params(): KeyTokenRemoved__Params {
    return new KeyTokenRemoved__Params(this);
  }
}

export class KeyTokenRemoved__Params {
  _event: KeyTokenRemoved;

  constructor(event: KeyTokenRemoved) {
    this._event = event;
  }

  get keyToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class MultipartTokenUpdated extends ethereum.Event {
  get params(): MultipartTokenUpdated__Params {
    return new MultipartTokenUpdated__Params(this);
  }
}

export class MultipartTokenUpdated__Params {
  _event: MultipartTokenUpdated;

  constructor(event: MultipartTokenUpdated) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get status(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class ReplacementTokenUpdated extends ethereum.Event {
  get params(): ReplacementTokenUpdated__Params {
    return new ReplacementTokenUpdated__Params(this);
  }
}

export class ReplacementTokenUpdated__Params {
  _event: ReplacementTokenUpdated;

  constructor(event: ReplacementTokenUpdated) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get replacementToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class SwapPlatformAdded extends ethereum.Event {
  get params(): SwapPlatformAdded__Params {
    return new SwapPlatformAdded__Params(this);
  }
}

export class SwapPlatformAdded__Params {
  _event: SwapPlatformAdded;

  constructor(event: SwapPlatformAdded) {
    this._event = event;
  }

  get factoryAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get name(): string {
    return this._event.parameters[1].value.toString();
  }
}

export class SwapPlatformRemoved extends ethereum.Event {
  get params(): SwapPlatformRemoved__Params {
    return new SwapPlatformRemoved__Params(this);
  }
}

export class SwapPlatformRemoved__Params {
  _event: SwapPlatformRemoved;

  constructor(event: SwapPlatformRemoved) {
    this._event = event;
  }

  get factoryAddress(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get name(): string {
    return this._event.parameters[1].value.toString();
  }
}

export class PriceCalculatorAbi__findLpInUniV3Result {
  value0: BigInt;
  value1: Address;

  constructor(value0: BigInt, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): Address {
    return this.value1;
  }
}

export class PriceCalculatorAbi__getLargestPoolResult {
  value0: Address;
  value1: BigInt;
  value2: Address;

  constructor(value0: Address, value1: BigInt, value2: Address) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    return map;
  }

  getValue0(): Address {
    return this.value0;
  }

  getValue1(): BigInt {
    return this.value1;
  }

  getValue2(): Address {
    return this.value2;
  }
}

export class PriceCalculatorAbi__getLpForFactoryResult {
  value0: BigInt;
  value1: Address;

  constructor(value0: BigInt, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): Address {
    return this.value1;
  }
}

export class PriceCalculatorAbi__getLpUnderlyingResult {
  value0: Array<Address>;
  value1: Array<BigInt>;

  constructor(value0: Array<Address>, value1: Array<BigInt>) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddressArray(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigIntArray(this.value1));
    return map;
  }

  getValue0(): Array<Address> {
    return this.value0;
  }

  getValue1(): Array<BigInt> {
    return this.value1;
  }
}

export class PriceCalculatorAbi extends ethereum.SmartContract {
  static bind(address: Address): PriceCalculatorAbi {
    return new PriceCalculatorAbi("PriceCalculatorAbi", address);
  }

  BALANCER_VAULT_ETHEREUM(): Address {
    let result = super.call(
      "BALANCER_VAULT_ETHEREUM",
      "BALANCER_VAULT_ETHEREUM():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_BALANCER_VAULT_ETHEREUM(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "BALANCER_VAULT_ETHEREUM",
      "BALANCER_VAULT_ETHEREUM():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  BEETHOVEN_VAULT_FANTOM(): Address {
    let result = super.call(
      "BEETHOVEN_VAULT_FANTOM",
      "BEETHOVEN_VAULT_FANTOM():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_BEETHOVEN_VAULT_FANTOM(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "BEETHOVEN_VAULT_FANTOM",
      "BEETHOVEN_VAULT_FANTOM():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  CONE_FACTORY(): Address {
    let result = super.call("CONE_FACTORY", "CONE_FACTORY():(address)", []);

    return result[0].toAddress();
  }

  try_CONE_FACTORY(): ethereum.CallResult<Address> {
    let result = super.tryCall("CONE_FACTORY", "CONE_FACTORY():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  CRV_USD_BTC_ETH_FANTOM(): Address {
    let result = super.call(
      "CRV_USD_BTC_ETH_FANTOM",
      "CRV_USD_BTC_ETH_FANTOM():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_CRV_USD_BTC_ETH_FANTOM(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "CRV_USD_BTC_ETH_FANTOM",
      "CRV_USD_BTC_ETH_FANTOM():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  CRV_USD_BTC_ETH_MATIC(): Address {
    let result = super.call(
      "CRV_USD_BTC_ETH_MATIC",
      "CRV_USD_BTC_ETH_MATIC():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_CRV_USD_BTC_ETH_MATIC(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "CRV_USD_BTC_ETH_MATIC",
      "CRV_USD_BTC_ETH_MATIC():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  DEPTH(): BigInt {
    let result = super.call("DEPTH", "DEPTH():(uint256)", []);

    return result[0].toBigInt();
  }

  try_DEPTH(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("DEPTH", "DEPTH():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  DYSTOPIA_FACTORY(): Address {
    let result = super.call(
      "DYSTOPIA_FACTORY",
      "DYSTOPIA_FACTORY():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_DYSTOPIA_FACTORY(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "DYSTOPIA_FACTORY",
      "DYSTOPIA_FACTORY():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  FIREBIRD_FACTORY(): Address {
    let result = super.call(
      "FIREBIRD_FACTORY",
      "FIREBIRD_FACTORY():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_FIREBIRD_FACTORY(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "FIREBIRD_FACTORY",
      "FIREBIRD_FACTORY():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  IRON_IS3USD(): string {
    let result = super.call("IRON_IS3USD", "IRON_IS3USD():(string)", []);

    return result[0].toString();
  }

  try_IRON_IS3USD(): ethereum.CallResult<string> {
    let result = super.tryCall("IRON_IS3USD", "IRON_IS3USD():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  IS3USD(): string {
    let result = super.call("IS3USD", "IS3USD():(string)", []);

    return result[0].toString();
  }

  try_IS3USD(): ethereum.CallResult<string> {
    let result = super.tryCall("IS3USD", "IS3USD():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  PRECISION_DECIMALS(): BigInt {
    let result = super.call(
      "PRECISION_DECIMALS",
      "PRECISION_DECIMALS():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_PRECISION_DECIMALS(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "PRECISION_DECIMALS",
      "PRECISION_DECIMALS():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  UNIV3_FACTORY_ETHEREUM(): Address {
    let result = super.call(
      "UNIV3_FACTORY_ETHEREUM",
      "UNIV3_FACTORY_ETHEREUM():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_UNIV3_FACTORY_ETHEREUM(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "UNIV3_FACTORY_ETHEREUM",
      "UNIV3_FACTORY_ETHEREUM():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  VERSION(): string {
    let result = super.call("VERSION", "VERSION():(string)", []);

    return result[0].toString();
  }

  try_VERSION(): ethereum.CallResult<string> {
    let result = super.tryCall("VERSION", "VERSION():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  allowedFactories(param0: Address): boolean {
    let result = super.call(
      "allowedFactories",
      "allowedFactories(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toBoolean();
  }

  try_allowedFactories(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "allowedFactories",
      "allowedFactories(address):(bool)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  checkFactory(pair: Address, compareFactory: Address): boolean {
    let result = super.call(
      "checkFactory",
      "checkFactory(address,address):(bool)",
      [
        ethereum.Value.fromAddress(pair),
        ethereum.Value.fromAddress(compareFactory)
      ]
    );

    return result[0].toBoolean();
  }

  try_checkFactory(
    pair: Address,
    compareFactory: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "checkFactory",
      "checkFactory(address,address):(bool)",
      [
        ethereum.Value.fromAddress(pair),
        ethereum.Value.fromAddress(compareFactory)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  computePrice(
    token: Address,
    outputToken: Address,
    usedLps: Array<Address>,
    deep: BigInt
  ): BigInt {
    let result = super.call(
      "computePrice",
      "computePrice(address,address,address[],uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(outputToken),
        ethereum.Value.fromAddressArray(usedLps),
        ethereum.Value.fromUnsignedBigInt(deep)
      ]
    );

    return result[0].toBigInt();
  }

  try_computePrice(
    token: Address,
    outputToken: Address,
    usedLps: Array<Address>,
    deep: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "computePrice",
      "computePrice(address,address,address[],uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(outputToken),
        ethereum.Value.fromAddressArray(usedLps),
        ethereum.Value.fromUnsignedBigInt(deep)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  controller(): Address {
    let result = super.call("controller", "controller():(address)", []);

    return result[0].toAddress();
  }

  try_controller(): ethereum.CallResult<Address> {
    let result = super.tryCall("controller", "controller():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  created(): BigInt {
    let result = super.call("created", "created():(uint256)", []);

    return result[0].toBigInt();
  }

  try_created(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("created", "created():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  createdBlock(): BigInt {
    let result = super.call("createdBlock", "createdBlock():(uint256)", []);

    return result[0].toBigInt();
  }

  try_createdBlock(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("createdBlock", "createdBlock():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  defaultToken(): Address {
    let result = super.call("defaultToken", "defaultToken():(address)", []);

    return result[0].toAddress();
  }

  try_defaultToken(): ethereum.CallResult<Address> {
    let result = super.tryCall("defaultToken", "defaultToken():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  findLpInUniV3(
    token: Address,
    tokenOpposite: Address
  ): PriceCalculatorAbi__findLpInUniV3Result {
    let result = super.call(
      "findLpInUniV3",
      "findLpInUniV3(address,address):(uint256,address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(tokenOpposite)
      ]
    );

    return new PriceCalculatorAbi__findLpInUniV3Result(
      result[0].toBigInt(),
      result[1].toAddress()
    );
  }

  try_findLpInUniV3(
    token: Address,
    tokenOpposite: Address
  ): ethereum.CallResult<PriceCalculatorAbi__findLpInUniV3Result> {
    let result = super.tryCall(
      "findLpInUniV3",
      "findLpInUniV3(address,address):(uint256,address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(tokenOpposite)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PriceCalculatorAbi__findLpInUniV3Result(
        value[0].toBigInt(),
        value[1].toAddress()
      )
    );
  }

  getLargestPool(
    token: Address,
    usedLps: Array<Address>
  ): PriceCalculatorAbi__getLargestPoolResult {
    let result = super.call(
      "getLargestPool",
      "getLargestPool(address,address[]):(address,uint256,address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddressArray(usedLps)
      ]
    );

    return new PriceCalculatorAbi__getLargestPoolResult(
      result[0].toAddress(),
      result[1].toBigInt(),
      result[2].toAddress()
    );
  }

  try_getLargestPool(
    token: Address,
    usedLps: Array<Address>
  ): ethereum.CallResult<PriceCalculatorAbi__getLargestPoolResult> {
    let result = super.tryCall(
      "getLargestPool",
      "getLargestPool(address,address[]):(address,uint256,address)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddressArray(usedLps)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PriceCalculatorAbi__getLargestPoolResult(
        value[0].toAddress(),
        value[1].toBigInt(),
        value[2].toAddress()
      )
    );
  }

  getLpForFactory(
    _factory: Address,
    token: Address,
    tokenOpposite: Address
  ): PriceCalculatorAbi__getLpForFactoryResult {
    let result = super.call(
      "getLpForFactory",
      "getLpForFactory(address,address,address):(uint256,address)",
      [
        ethereum.Value.fromAddress(_factory),
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(tokenOpposite)
      ]
    );

    return new PriceCalculatorAbi__getLpForFactoryResult(
      result[0].toBigInt(),
      result[1].toAddress()
    );
  }

  try_getLpForFactory(
    _factory: Address,
    token: Address,
    tokenOpposite: Address
  ): ethereum.CallResult<PriceCalculatorAbi__getLpForFactoryResult> {
    let result = super.tryCall(
      "getLpForFactory",
      "getLpForFactory(address,address,address):(uint256,address)",
      [
        ethereum.Value.fromAddress(_factory),
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(tokenOpposite)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PriceCalculatorAbi__getLpForFactoryResult(
        value[0].toBigInt(),
        value[1].toAddress()
      )
    );
  }

  getLpSize(pairAddress: Address, token: Address): BigInt {
    let result = super.call(
      "getLpSize",
      "getLpSize(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(pairAddress),
        ethereum.Value.fromAddress(token)
      ]
    );

    return result[0].toBigInt();
  }

  try_getLpSize(
    pairAddress: Address,
    token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLpSize",
      "getLpSize(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(pairAddress),
        ethereum.Value.fromAddress(token)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLpUnderlying(
    lpAddress: Address
  ): PriceCalculatorAbi__getLpUnderlyingResult {
    let result = super.call(
      "getLpUnderlying",
      "getLpUnderlying(address):(address[2],uint256[2])",
      [ethereum.Value.fromAddress(lpAddress)]
    );

    return new PriceCalculatorAbi__getLpUnderlyingResult(
      result[0].toAddressArray(),
      result[1].toBigIntArray()
    );
  }

  try_getLpUnderlying(
    lpAddress: Address
  ): ethereum.CallResult<PriceCalculatorAbi__getLpUnderlyingResult> {
    let result = super.tryCall(
      "getLpUnderlying",
      "getLpUnderlying(address):(address[2],uint256[2])",
      [ethereum.Value.fromAddress(lpAddress)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new PriceCalculatorAbi__getLpUnderlyingResult(
        value[0].toAddressArray(),
        value[1].toBigIntArray()
      )
    );
  }

  getPrice(token: Address, outputToken: Address): BigInt {
    let result = super.call("getPrice", "getPrice(address,address):(uint256)", [
      ethereum.Value.fromAddress(token),
      ethereum.Value.fromAddress(outputToken)
    ]);

    return result[0].toBigInt();
  }

  try_getPrice(
    token: Address,
    outputToken: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPrice",
      "getPrice(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromAddress(outputToken)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriceFromLp(lpAddress: Address, token: Address): BigInt {
    let result = super.call(
      "getPriceFromLp",
      "getPriceFromLp(address,address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress), ethereum.Value.fromAddress(token)]
    );

    return result[0].toBigInt();
  }

  try_getPriceFromLp(
    lpAddress: Address,
    token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPriceFromLp",
      "getPriceFromLp(address,address):(uint256)",
      [ethereum.Value.fromAddress(lpAddress), ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPriceWithDefaultOutput(token: Address): BigInt {
    let result = super.call(
      "getPriceWithDefaultOutput",
      "getPriceWithDefaultOutput(address):(uint256)",
      [ethereum.Value.fromAddress(token)]
    );

    return result[0].toBigInt();
  }

  try_getPriceWithDefaultOutput(token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getPriceWithDefaultOutput",
      "getPriceWithDefaultOutput(address):(uint256)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getUniV3Price(pool: Address, tokenIn: Address): BigInt {
    let result = super.call(
      "getUniV3Price",
      "getUniV3Price(address,address):(uint256)",
      [ethereum.Value.fromAddress(pool), ethereum.Value.fromAddress(tokenIn)]
    );

    return result[0].toBigInt();
  }

  try_getUniV3Price(
    pool: Address,
    tokenIn: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getUniV3Price",
      "getUniV3Price(address,address):(uint256)",
      [ethereum.Value.fromAddress(pool), ethereum.Value.fromAddress(tokenIn)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getUniV3Reserve(pairAddress: Address, token: Address): BigInt {
    let result = super.call(
      "getUniV3Reserve",
      "getUniV3Reserve(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(pairAddress),
        ethereum.Value.fromAddress(token)
      ]
    );

    return result[0].toBigInt();
  }

  try_getUniV3Reserve(
    pairAddress: Address,
    token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getUniV3Reserve",
      "getUniV3Reserve(address,address):(uint256)",
      [
        ethereum.Value.fromAddress(pairAddress),
        ethereum.Value.fromAddress(token)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isAave(token: Address): boolean {
    let result = super.call("isAave", "isAave(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);

    return result[0].toBoolean();
  }

  try_isAave(token: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isAave", "isAave(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isBPT(token: Address): boolean {
    let result = super.call("isBPT", "isBPT(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);

    return result[0].toBoolean();
  }

  try_isBPT(token: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isBPT", "isBPT(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isController(_value: Address): boolean {
    let result = super.call("isController", "isController(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);

    return result[0].toBoolean();
  }

  try_isController(_value: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isController", "isController(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isGovernance(_value: Address): boolean {
    let result = super.call("isGovernance", "isGovernance(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);

    return result[0].toBoolean();
  }

  try_isGovernance(_value: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isGovernance", "isGovernance(address):(bool)", [
      ethereum.Value.fromAddress(_value)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isIronPair(token: Address): boolean {
    let result = super.call("isIronPair", "isIronPair(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);

    return result[0].toBoolean();
  }

  try_isIronPair(token: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isIronPair", "isIronPair(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isKeyToken(token: Address): boolean {
    let result = super.call("isKeyToken", "isKeyToken(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);

    return result[0].toBoolean();
  }

  try_isKeyToken(token: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isKeyToken", "isKeyToken(address):(bool)", [
      ethereum.Value.fromAddress(token)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSwapFactoryToken(adr: Address): boolean {
    let result = super.call(
      "isSwapFactoryToken",
      "isSwapFactoryToken(address):(bool)",
      [ethereum.Value.fromAddress(adr)]
    );

    return result[0].toBoolean();
  }

  try_isSwapFactoryToken(adr: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isSwapFactoryToken",
      "isSwapFactoryToken(address):(bool)",
      [ethereum.Value.fromAddress(adr)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSwapName(name: string): boolean {
    let result = super.call("isSwapName", "isSwapName(string):(bool)", [
      ethereum.Value.fromString(name)
    ]);

    return result[0].toBoolean();
  }

  try_isSwapName(name: string): ethereum.CallResult<boolean> {
    let result = super.tryCall("isSwapName", "isSwapName(string):(bool)", [
      ethereum.Value.fromString(name)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isSwapPlatform(token: Address): boolean {
    let result = super.call(
      "isSwapPlatform",
      "isSwapPlatform(address):(bool)",
      [ethereum.Value.fromAddress(token)]
    );

    return result[0].toBoolean();
  }

  try_isSwapPlatform(token: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isSwapPlatform",
      "isSwapPlatform(address):(bool)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  keyTokens(param0: BigInt): Address {
    let result = super.call("keyTokens", "keyTokens(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_keyTokens(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("keyTokens", "keyTokens(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  keyTokensSize(): BigInt {
    let result = super.call("keyTokensSize", "keyTokensSize():(uint256)", []);

    return result[0].toBigInt();
  }

  try_keyTokensSize(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "keyTokensSize",
      "keyTokensSize():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  replacementTokens(param0: Address): Address {
    let result = super.call(
      "replacementTokens",
      "replacementTokens(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );

    return result[0].toAddress();
  }

  try_replacementTokens(param0: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "replacementTokens",
      "replacementTokens(address):(address)",
      [ethereum.Value.fromAddress(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  swapFactories(param0: BigInt): Address {
    let result = super.call(
      "swapFactories",
      "swapFactories(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return result[0].toAddress();
  }

  try_swapFactories(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "swapFactories",
      "swapFactories(uint256):(address)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  swapFactoriesSize(): BigInt {
    let result = super.call(
      "swapFactoriesSize",
      "swapFactoriesSize():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_swapFactoriesSize(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "swapFactoriesSize",
      "swapFactoriesSize():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  swapLpNames(param0: BigInt): string {
    let result = super.call("swapLpNames", "swapLpNames(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toString();
  }

  try_swapLpNames(param0: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("swapLpNames", "swapLpNames(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  unwrapAaveIfNecessary(token: Address): Address {
    let result = super.call(
      "unwrapAaveIfNecessary",
      "unwrapAaveIfNecessary(address):(address)",
      [ethereum.Value.fromAddress(token)]
    );

    return result[0].toAddress();
  }

  try_unwrapAaveIfNecessary(token: Address): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "unwrapAaveIfNecessary",
      "unwrapAaveIfNecessary(address):(address)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AddKeyTokenCall extends ethereum.Call {
  get inputs(): AddKeyTokenCall__Inputs {
    return new AddKeyTokenCall__Inputs(this);
  }

  get outputs(): AddKeyTokenCall__Outputs {
    return new AddKeyTokenCall__Outputs(this);
  }
}

export class AddKeyTokenCall__Inputs {
  _call: AddKeyTokenCall;

  constructor(call: AddKeyTokenCall) {
    this._call = call;
  }

  get newToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class AddKeyTokenCall__Outputs {
  _call: AddKeyTokenCall;

  constructor(call: AddKeyTokenCall) {
    this._call = call;
  }
}

export class AddKeyTokensCall extends ethereum.Call {
  get inputs(): AddKeyTokensCall__Inputs {
    return new AddKeyTokensCall__Inputs(this);
  }

  get outputs(): AddKeyTokensCall__Outputs {
    return new AddKeyTokensCall__Outputs(this);
  }
}

export class AddKeyTokensCall__Inputs {
  _call: AddKeyTokensCall;

  constructor(call: AddKeyTokensCall) {
    this._call = call;
  }

  get newTokens(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }
}

export class AddKeyTokensCall__Outputs {
  _call: AddKeyTokensCall;

  constructor(call: AddKeyTokensCall) {
    this._call = call;
  }
}

export class AddSwapPlatformCall extends ethereum.Call {
  get inputs(): AddSwapPlatformCall__Inputs {
    return new AddSwapPlatformCall__Inputs(this);
  }

  get outputs(): AddSwapPlatformCall__Outputs {
    return new AddSwapPlatformCall__Outputs(this);
  }
}

export class AddSwapPlatformCall__Inputs {
  _call: AddSwapPlatformCall;

  constructor(call: AddSwapPlatformCall) {
    this._call = call;
  }

  get _factoryAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _name(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class AddSwapPlatformCall__Outputs {
  _call: AddSwapPlatformCall;

  constructor(call: AddSwapPlatformCall) {
    this._call = call;
  }
}

export class ChangeFactoriesStatusCall extends ethereum.Call {
  get inputs(): ChangeFactoriesStatusCall__Inputs {
    return new ChangeFactoriesStatusCall__Inputs(this);
  }

  get outputs(): ChangeFactoriesStatusCall__Outputs {
    return new ChangeFactoriesStatusCall__Outputs(this);
  }
}

export class ChangeFactoriesStatusCall__Inputs {
  _call: ChangeFactoriesStatusCall;

  constructor(call: ChangeFactoriesStatusCall) {
    this._call = call;
  }

  get factories(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }

  get status(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class ChangeFactoriesStatusCall__Outputs {
  _call: ChangeFactoriesStatusCall;

  constructor(call: ChangeFactoriesStatusCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _controller(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class InitializeControllableCall extends ethereum.Call {
  get inputs(): InitializeControllableCall__Inputs {
    return new InitializeControllableCall__Inputs(this);
  }

  get outputs(): InitializeControllableCall__Outputs {
    return new InitializeControllableCall__Outputs(this);
  }
}

export class InitializeControllableCall__Inputs {
  _call: InitializeControllableCall;

  constructor(call: InitializeControllableCall) {
    this._call = call;
  }

  get __controller(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitializeControllableCall__Outputs {
  _call: InitializeControllableCall;

  constructor(call: InitializeControllableCall) {
    this._call = call;
  }
}

export class RemoveKeyTokenCall extends ethereum.Call {
  get inputs(): RemoveKeyTokenCall__Inputs {
    return new RemoveKeyTokenCall__Inputs(this);
  }

  get outputs(): RemoveKeyTokenCall__Outputs {
    return new RemoveKeyTokenCall__Outputs(this);
  }
}

export class RemoveKeyTokenCall__Inputs {
  _call: RemoveKeyTokenCall;

  constructor(call: RemoveKeyTokenCall) {
    this._call = call;
  }

  get keyToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RemoveKeyTokenCall__Outputs {
  _call: RemoveKeyTokenCall;

  constructor(call: RemoveKeyTokenCall) {
    this._call = call;
  }
}

export class RemoveSwapPlatformCall extends ethereum.Call {
  get inputs(): RemoveSwapPlatformCall__Inputs {
    return new RemoveSwapPlatformCall__Inputs(this);
  }

  get outputs(): RemoveSwapPlatformCall__Outputs {
    return new RemoveSwapPlatformCall__Outputs(this);
  }
}

export class RemoveSwapPlatformCall__Inputs {
  _call: RemoveSwapPlatformCall;

  constructor(call: RemoveSwapPlatformCall) {
    this._call = call;
  }

  get _factoryAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _name(): string {
    return this._call.inputValues[1].value.toString();
  }
}

export class RemoveSwapPlatformCall__Outputs {
  _call: RemoveSwapPlatformCall;

  constructor(call: RemoveSwapPlatformCall) {
    this._call = call;
  }
}

export class SetDefaultTokenCall extends ethereum.Call {
  get inputs(): SetDefaultTokenCall__Inputs {
    return new SetDefaultTokenCall__Inputs(this);
  }

  get outputs(): SetDefaultTokenCall__Outputs {
    return new SetDefaultTokenCall__Outputs(this);
  }
}

export class SetDefaultTokenCall__Inputs {
  _call: SetDefaultTokenCall;

  constructor(call: SetDefaultTokenCall) {
    this._call = call;
  }

  get _newDefaultToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetDefaultTokenCall__Outputs {
  _call: SetDefaultTokenCall;

  constructor(call: SetDefaultTokenCall) {
    this._call = call;
  }
}

export class SetReplacementTokensCall extends ethereum.Call {
  get inputs(): SetReplacementTokensCall__Inputs {
    return new SetReplacementTokensCall__Inputs(this);
  }

  get outputs(): SetReplacementTokensCall__Outputs {
    return new SetReplacementTokensCall__Outputs(this);
  }
}

export class SetReplacementTokensCall__Inputs {
  _call: SetReplacementTokensCall;

  constructor(call: SetReplacementTokensCall) {
    this._call = call;
  }

  get _inputToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _replacementToken(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class SetReplacementTokensCall__Outputs {
  _call: SetReplacementTokensCall;

  constructor(call: SetReplacementTokensCall) {
    this._call = call;
  }
}
